# CloudRun Protection

* 1 [Presentation](#presentation)
* 2 [How to use the SWF CloudRun protection](#how-to-use-the-swf-cloudrun-protection)
* 3 [Backup](#backup)


# Presentation
When creating an application using Cloud Run, you can require authentication to access it. Once it is set, you can add principals to set which account can access the application. Accounts authorized by the application can request it using their tokens. Our solution helps you protect your Cloud Run application by making the whole authentication process and request go through the WAF.

The `SWF - GCP - Get AccountService token` works as follow : 
- First, it checks for the gcp_token variable in the datastore. The gcp_token value will be present if a previous request succeeds.
- If the gcp_token value is present, the SWF setup the request header with the Authorization header containing the token and forward the request.
- If not, the SWF checks if the previous failed request was more thant 15 seconds ago to avoid failed requests spamming.
- Once the check is done, the SWF makes a request to the google metadata URL and retrieve the token of the current Service Account of the compute engine.
- If the request fail, the SWF raised an error and create a log.
- If the request succeeds and the SWF is able to retrieve the token, the value is stored in a datastore. The SWF set the Authorization header with the token.

Concerning the SWF parameters and attribute :
> `metadata.ip` is the google metadata IP by default `169.254.169.254`. You can only change it in the SWF parameters as follow :
![SWF metadata.ip parameter](./attachements/metadata.ip.png "SWF metadata.ip parameter")

> `retry.time` is the wainting time between two requests for retrieving the token. You can set this in directly in the node : 
![SWF retry.time parameter](./attachements/retry.time.png "SWF retry.time parameter")

> The SWF return the attribute `gcp_token`.

# How to use the SWF CloudRun protection

The schema of the following captures shows an example of a workflow that deploys a basic configuration to use the `Auto Normalization engine` with `ÃŒCX engine`:

![An example of an Auto Normalization with ICX deployement](./attachements/norm_icx.png "An example of an Auto Normalization with ICX deployement")

First, we need to configure the value of the ` Maximum number of decodings`. Herein an example the value is set to 3:

![The Auto Normalization engine node](./attachements/norm_conf.png "The Auto Normalization engine node")

If the handled request is encoded more than MAX times, then the `normalized.remaining` value will be set to `true` and workflow should block the request.

Otherwise the `Auto Normalization engine` decodes the request and the result is used later by the `ICX engine`. The latter does not require the `normalized.http.request` attribute or does not have to be selected in the node parameter. `ICX engine` will automatically take the `normalized.http.request` attribute if available before in the workflow. If not, the `ICX engine` will analyse the request from default `http.*` attributes.

Next, we will present two attack cases and explain how this security use case can protect the system from encoded injections.

## Attack case 1

An attacker wants to inject `/bin/cmd.exe` at the request quey:
- first, it encodes it 2 times and obtains `TDJKcGJpOWpiV1F1WlhobA==`;
- then, sends it to the WAAP tunnel;
- the encoded injection is decoded by the WAAP without `normalized.remaining`;
- the ICX engine detects the injection and the attack is blocked.

Herein the obtained log:

![An ICX log alert about the detected injection](./attachements/log_icx.png "An ICX log alert about the detected injection")

![An ICX log alert about the detected injection](./attachements/log_icx2.png "An ICX log alert about the detected injection")

> Note: the event is generated by a `Log Alert` deployed in the workflow and not by the node.

## Attack case 2

An attacker wants to inject `/bin/cmd.exe` at the request quey:
- first, it encodes it MAX + 1 times (4 times in this example) and obtains `VkVSS1MyTkhTbkJQVjNCcFZqRkdNVmRzYUc5aVFUMDk=`;
- then, sends it to the WAAP tunnel;
- the encoded injection is not completely decoded by the `Auto Normalization engine` (`normalized.remaining` = `true`);
- the workflow directly blocks the attack.

![A log alert about the detected remaining encoding](./attachements/log_exceed_max.png "A log alert about the detected remaining encoding")

![A log alert about the detected remaining encoding](./attachements/log_exceed_max2.png "A log alert about the detected remaining encoding")

> Note: the event is generated by a `Custom Security Alert` deployed in the workflow and not by the node.

# Backup

> Important, in the WAAP version 6.10.0, the `Auto Normalization engine` is integrated by default at the `WAAP default` and `HTTP and Websocket` workflows.

A backup of the explained use case of `Auto Normalization engine` can be downloaded here: [ `Auto Normalization engine use case`](./backup/WAAP%20Normalization.backup).
