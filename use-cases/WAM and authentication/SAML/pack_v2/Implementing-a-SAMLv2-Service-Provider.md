# Implementing a SAMLv2 Service Provider (pack 2.0.1)

This use case requires at least the SAML pack 2.0.1: [SAML-pack-2.0.1.backup](./attachments/SAML-pack-2.0.1.backup).

## Overview

Two implementations are provided as examples: with HTTP Post Binding and with HTTP Redirect binding. The main Workflows (**Sample: SAMLv2 SP HTTP Post Binding** and **Sample: SAMLv2 SP HTTP Redirect binding**) contain nodes that:

* generate an authentication request (AuthnRequest) and send it to an external SAMLv2 Identity Provider,
* receive and “consume” the SAML assertion received from the client, containing the proof of its authenticity. Access to the backend is then authorized

The following diagram shows the exchanges between the different components.

![](./attachments/55270135.png)

1. The user attempts to access the protected site. On the WAAP side, no SAML identifier (saml.id) is found in the user’s session, or no session exists (**Get saml.id from session** node).
2. An authentication request (AuthnRequest) SAML message is generated by the **SAML: Generate request** node, then is returned (**SAML: Send request to IdP**) so that the user sends the request to an external Identity Provider (IdP).
3. The user sends the request to the IdP.
4. The IdP authenticates the user.
5. Several exchanges between the user and the IdP may be necessary to verify his/her authenticity (for example for challenge-response authentication).
6. After the user is authenticated, the IdP generates a message (assertion) confirming authenticity and returns it to the user.
7. The user sends the authentication assertion to the WAAP (generally by automatically following an auto-submit form generated by the IdP).
8. The **SAML: Decode assertion** node decodes the assertion that was received and performs various verifications (signature, dates, request identifier, etc.) If the verifications are conclusive, the identifier is stored in the session (**saml.id**).
9. The subsequent requests are then sent to the application (for as long as the user’s HTTP session lasts)

The **SAML: Service Provider Sample** Workflow contains the minimum nodes for SAMLv2 authentication on the Service provider side:

![](./attachments/55270987.png)

## Details of nodes

### SAML: Generate request

This node is responsible for generating an authentication request (AuthnRequest).

![](./attachments/55270986.png)

#### Parameters

* **Request type**: For the authentication request, choose **AuthnRequest**.
* **IdP Recipient URL**: The complete address to which the user is to be sent for sending the authentication request. This parameter is supplied by the IdP.
* **SP Name**: The Service Provider’s identifier, specific to the protected application. This name must be sent to the IdP beforehand, when the trust relationship is established.
* **Issuer**: The identifier of the issuer of the authentication request. This name must be sent to the IdP beforehand, when the trust relationship is established.
* **ForceAuthn**: SAML forceAuthn
* **Subject NameID**: Allows to specify a specific NameID.
* **Extension**: Optional parameter. The text in the input box will be inserted as a sub-element of the  tag.
* **Protocol Binding for response**: Specifies how we want the IdP to respond to SP (POST or redirect)
* **ACS URL**: The complete address of the consumer of the authentication assertion (that is, the URL that must be used to reach the node **SAML: Decode assertion** node). This path corresponds to the URL in you application (Tunnel and his workflow) on which the IdP will send the authentication response. This address must be sent to the IdP beforehand, when the trust relationship is established. 
* **Store pending requests**: Enables the mechanism for associating a request and a response. If this parameter is enabled, it must also be enabled in the **SAML: Decode assertion** node. The identifier of each SAML request will be stored in memory.
* **Pending requests SHM Datastore**: Chooses the SHM datastore.

#### Provided Attributes

* **xml.saml.request.doc**: The node provides the authentication request (used by the **SAML: Send request to IdP** node) in XmlDoc format. In this way, it’s possible to alter it (to insert additional attributes, for example) with the XML Modify node.
* **xml.saml.recipient.url**: The address of the IdP, used by the **SAML: Send request to IdP** node.
* **xml.saml.request.id**: The ID of the generated SAML request

### SAML: Send request to IdP

This node generates a response (in the Workflow and HTTP sense) containing the authentication request to be sent to the IdP.

![](./attachments/55270133.png)

#### Parameters

* **Binding**: The format for sending the authentication request. Possible choices: Redirect, AutoPost.
* **Request Signing**: Enable request signing
* **Signing algorithm**: Signature algorithm
* **Signing digest**: Signature digest method
* **Signing keystore**: The keystore selector for signing key
* **Signing key**: The private key to sign request
* **Enable ADFS2 compatibility**: For ADFS2 connectivity, signature nodes must contain an additional canonicalization transformation.

### SAML: Decode assertion

This node is responsible for decoding the assertion, verifying its authenticity, and validating the conditions.

![](./attachments/55270119.png)

#### Parameters

* **Session Cache**: The session cache (linked to a BWSESSIONID Cookie) that serves to establish an HTTP session with the user once his/her authenticity has been established. The **NameID** derived from the assertion is stored in the session, under the **saml.id** key.
* **Read assertion in**: Allows to specify where you want to read the assertion according to response binding method (any, post vars or query).
* **XML Keystore for signature validation and encryption**: Selects the Keystores containing the certificate chain to verify response signature and perform decryption.
* **Verify Signature**: Enables/disables verification of the assertion signature.
* **Extract CN**: Enable extraction of the CN of the signing certificate.
* **Verify NotBefore/NotOnOrAfter**: Enables/disables verification of the validity date of the assertion. The current date (on the WAAP) is compared to the “NotBefore” and “NotOnOrAfter” dates specified in the assertion.
* **NotBefore tolerance (s)**: The tolerance (optional), in seconds, for the “NotBefore” limit. The number of seconds is subtracted from the limit before comparison.
* **NotAfter tolerance (s)**: The tolerance (optional), in seconds, for the “NotOnOrAfter” limit. The number of seconds is added to the limit before comparison.
* **Check pending request**: Enables the mechanism for associating a request and a response. If this parameter is enabled, it must also be enabled in the **SAML: Decode assertion** node. The assertion will be validated only if the identifier specified in the “InResponseTo” attribute of the assertion is already in memory.
* **Pending requests SHM Datastore**: Chooses the SHM datastore. The latter must be the same as the one specified in the parameter with the same name of the **SAML: Generate request** node.
* **Log success in WAM logs**: enable logging of successfull events
* **Log errors in WAM logs**: enable logging of error events

#### Provided Attributes

* **xml.saml.assertion.nameid**: The identifier of the authenticated user. This identifier is also stored in the session under the **saml.id** key.
* **xml.saml.assertion.sessionindex**: The session index received on successful authentication.
* **xml.saml.assertion.doc**: The SAML assertion in XmlDoc format. This attribute can then be manipulated by the XML Get node.
* **xml.saml.assertion.failure**: Boolean that returns True when an error is raised. When an error occurs, a message specifying the error is provided in the xml.saml.assertion.err\_message attribute.
* **xml.saml.assertion.err\_message**: The error message when the xml.saml.assertion.failure attribute is True.
* **xml.saml.assertion.inresponseto**: the SAML ID of the request the assertion refers
* **xml.saml.assertion.cn**: The extracted CN (see **Extract CN** parameter)

## Choosing datastores and session caches

The datastores (used for pending requests) and the session cache (active sessions) are not used for exchanging data among themselves, and therefore it is possible to completely separate the different datastores and session caches. However, if a common datastore (for storing pending requests) is used among several **SAML: Generate Request** and several **SAML: Decode assertion** nodes, then the pending requests will be validated regardless of origin (using a common datastore); the storage key is the same as the ID of the request.

The advantage of sharing a datastore is that it makes configuration easier. The advantage of using multiple datastores is that it provides fine control over timeouts, number of entries, etc., which can be useful when settings need to be optimized to deal with increased loads.

It is recommended that specific datastores be used for pending requests, typically with a fixed timeout setting equivalent to the desired maximum duration of a pending request, an average size of 40, and a maximum number of entries to be determined (max pending requests at an instant t).

## Troubleshooting

Time synchronisation between the WAAP and your IdP is very important, be sure times on both equipment are well configured.

With self signed certificates, it may be necessary to use the 'Trust forced' option in your keystore items (ex. the public key of the  signature of the IdP).

There are a few specificities when using an ADFS server as IdP.

* The tunnel holding the workflow must be configured with SSL, the ADFS server will refuse sending assertions in clear traffic.
* When using ****Send request to IdP**** node the parameter **Enable ADFS2 compatibility** must be enabled
* When using ****Send request to IdP**** node the signing algorithm and method must be at least 256.
